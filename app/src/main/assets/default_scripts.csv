"id","name","author","description","content"
"1","Profanity Tagger","Az <hereliesaz@gmail.com>","A simple script to tag any evidence containing common curse words. Useful for establishing a general tone of communication.","const curses = [""f***"", ""s***"", ""b****"", ""a******""];\nconst text = evidence.text.toLowerCase();\nif (curses.some(word => text.includes(word))) {\n    addTag(""Profanity"");\n}"
"2","Financial Transaction Tagger","Az <hereliesaz@gmail.com>","Identifies and tags any mention of money or financial transactions.","const financialRegex = /[$€£¥]|\\b(dollar|euro|yen|pound|payment|paid|owe|money)\\b/i;\nif (financialRegex.test(evidence.text)) {\n    addTag(""Financial"");\n}"
"3","Contact Information Extractor","Az <hereliesaz@gmail.com>","Finds and tags phone numbers and email addresses, making it easy to find contact details later.","const emailRegex = /\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b/i;\nconst phoneRegex = /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/;\nif (emailRegex.test(evidence.text)) {\n    addTag(""Email Address"");\n}\nif (phoneRegex.test(evidence.text)) {\n    addTag(""Phone Number"");\n}"
"4","Appointment & Deadline Tagger","Az <hereliesaz@gmail.com>","Scans for mentions of specific dates, appointments, or deadlines.","const deadlineRegex = /\\b(appointment|meeting|deadline|due on|court date)\\b/i;\nif (deadlineRegex.test(evidence.text)) {\n    addTag(""Deadline/Appointment"");\n}"
"5","Gaslighting Detector","Az <hereliesaz@gmail.com>","Identifies phrases commonly used in gaslighting to deny a person's reality.","const gaslightingPhrases = [""you're crazy"", ""that never happened"", ""you're imagining things"", ""you're too sensitive"", ""I never said that""];\nconst text = evidence.text.toLowerCase();\nif (gaslightingPhrases.some(phrase => text.includes(phrase))) {\n    addTag(""Gaslighting"");\n    linkToAllegation(""Emotional Abuse"");\n}"
"6","Threat Severity Assessor","Az <hereliesaz@gmail.com>","A more nuanced threat detector that assigns a severity level based on the type of threat.","const lowSeverity = [""i'll make you pay""];\nconst medSeverity = [""i'll ruin your life""];\nconst highSeverity = [""i'm going to hurt you"", ""i'll kill you""];\nconst text = evidence.text.toLowerCase();\n\nif (highSeverity.some(p => text.includes(p))) {\n    addTag(""Threat"");\n    setSeverity(""Critical"");\n} else if (medSeverity.some(p => text.includes(p))) {\n    addTag(""Threat"");\n    setSeverity(""High"");\n} else if (lowSeverity.some(p => text.includes(p))) {\n    addTag(""Threat"");\n    setSeverity(""Medium"");\n}"
"7","Custody Violation Tagger","Az <hereliesaz@gmail.com>","Specifically for family law cases, this script looks for violations of custody agreements.","const violationPhrases = [""you can't see the kids"", ""i'm not bringing him back"", ""it's not your weekend""];\nif (violationPhrases.some(p => evidence.text.toLowerCase().includes(p))) {\n    addTag(""Custody Violation"");\n    linkToAllegation(""Child Custody Interference"");\n}"
"8","Admission of Guilt Detector","Az <hereliesaz@gmail.com>","Flags phrases that could be interpreted as an admission of wrongdoing.","const admissionPhrases = [""i know i messed up"", ""it was my fault"", ""i'm sorry i did that"", ""i shouldn't have""];\nif (admissionPhrases.some(p => evidence.text.toLowerCase().includes(p))) {\n    addTag(""Admission"");\n}"
"9","Stalking Pattern Detector","Az <hereliesaz@gmail.com>","This script looks for patterns of stalking by correlating location mentions across multiple pieces of evidence.","const locationRegex = /i saw you at (.+?)\\b/i;\nconst match = evidence.text.match(locationRegex);\nif (match) {\n    const location = match[1];\n    addTag(`Location Mention: ${location}`);\n    const otherMentions = case.evidence.filter(e =>\n        e.tags.some(t => t.startsWith(""Location Mention:""))\n    );\n    if (otherMentions.length > 2) {\n        addTag(""Stalking Pattern"");\n        linkToAllegation(""Stalking"");\n        createNote(`Multiple uninvited location mentions detected. Potential stalking behavior.`);\n    }\n}"
"10","Contradiction Finder","Az <hereliesaz@gmail.com>","Scans other evidence to find direct contradictions.","const promiseRegex = /i promise to (pay you|give you)(.+?)\\b/i;\nconst denialRegex = /i never promised to (pay you|give you)(.+?)\\b/i;\n\nconst promiseMatch = evidence.text.match(promiseRegex);\nif (promiseMatch) {\n    const promisedItem = promiseMatch[2].trim();\n    const contradiction = case.evidence.find(e => {\n        const denialMatch = e.text.match(denialRegex);\n        return denialMatch && denialMatch[2].trim() === promisedItem;\n    });\n    if (contradiction) {\n        addTag(""Contradiction"");\n        createNote(`This contradicts evidence from ${contradiction.metadata.date}.`);\n    }\n}"
"11","Escalation Tracker","Az <hereliesaz@gmail.com>","Tracks the severity of threats over time to show a pattern of escalation.","if (evidence.tags.includes(""Threat"")) {\n    const pastThreats = case.evidence.filter(e =>\n        e.tags.includes(""Threat"") && new Date(e.metadata.date) < new Date(evidence.metadata.date)\n    );\n    const pastSeverity = pastThreats.map(e => e.metadata.severity);\n    if (pastSeverity.includes(""Medium"") && evidence.metadata.severity === ""High"") {\n        addTag(""Escalating Behavior"");\n        createNote(""Severity has escalated from Medium to High."");\n    }\n}"
"12","Alibi Corroborator/Breaker","Az <hereliesaz@gmail.com>","Checks for consistencies or inconsistencies in alibis.","const alibiRegex = /i was at (.+?) at (\\d{1,2}:\\d{2}[ap]m)/i;\nconst match = evidence.text.match(alibiRegex);\nif (match) {\n    const location = match[1];\n    const time = match[2];\n    addTag(`Alibi: ${location} at ${time}`);\n    const conflictingEvidence = case.evidence.find(e =>\n        e.text.includes(`i saw you at a different place at ${time}`)\n    );\n    if (conflictingEvidence) {\n        addTag(""Alibi Conflict"");\n    }\n}"
"13","Third-Party Witness Identifier","Az <hereliesaz@gmail.com>","Scans for mentions of other people who could be potential witnesses.","const witnessRegex = /\\b(ask|talk to|with|saw|told) ([A-Z][a-z]+)\\b/g;\nlet match;\nwhile ((match = witnessRegex.exec(evidence.text)) !== null) {\n    const witnessName = match[2];\n    if (witnessName.toLowerCase() !== ""you"") {\n        addTag(`Potential Witness: ${witnessName}`);\n    }\n}"
"14","Document Request Generator","Az <hereliesaz@gmail.com>","Identifies mentions of documents that you might need to request in discovery.","const docRegex = /\\b(contract|agreement|lease|receipt|invoice|bank statement)\\b/ig;\nlet match;\nwhile ((match = docRegex.exec(evidence.text)) !== null) {\n    addTag(""Mentioned Document"");\n    createNote(`Discovery suggestion: Request the '${match[0]}' mentioned here.`);\n}"
"15","Communication Blackout Detector","Az <hereliesaz@gmail.com>","Identifies sudden and prolonged gaps in communication, which can be significant.","const lastCommunication = case.evidence\n    .filter(e => e.metadata.source === evidence.metadata.source)\n    .sort((a, b) => new Date(b.metadata.date) - new Date(a.metadata.date))[1]; // Get the one before this one\n\nif (lastCommunication) {\n    const daysSince = (new Date(evidence.metadata.date) - new Date(lastCommunication.metadata.date)) / (1000 * 3600 * 24);\n    if (daysSince > 14) { // 2-week gap\n        addTag(""Communication Gap"");\n        createNote(`A ${Math.round(daysSince)}-day gap in communication occurred before this message.`);\n    }\n}"
"16","""If This, Then That"" Coercion Analyzer","Az <hereliesaz@gmail.com>","A more advanced script to detect coercive ""if-then"" statements.","const coercionRegex = /if you (don't|won't) (.+?), (then )?i will (.+)/i;\nconst match = evidence.text.match(coercionRegex);\nif (match) {\n    const demand = match[2];\n    const consequence = match[4];\n    addTag(""Coercion"");\n    linkToAllegation(""Coercion/Blackmail"");\n    createNote(`Coercive statement detected. Demand: '${demand}', Consequence: '${consequence}'.`);\n}"
"17","Semantic Shift Analysis (Functional)","Az <hereliesaz@gmail.com>","Detects a significant semantic shift in communication style or topic by comparing the current evidence to the recent history. This can indicate a change in tone, strategy, or the start of a new conflict.","// This script detects a significant semantic shift by comparing the current\n// evidence's meaning to the combined meaning of recent evidence.\nconst recentEvidence = case.evidence.slice(-5);\nif (recentEvidence.length < 5) {\n    // Not enough history to compare.\n    return;\n}\n\n// Create a single representative text for the recent history.\nconst recentHistoryText = recentEvidence.map(e => e.text).join(' ');\n\n// Use the efficient, native calculateSimilarity function.\nconst similarity = lex.ai.local.calculateSimilarity(evidence.text, recentHistoryText);\n\n// A low similarity (high distance) indicates a shift in topic or sentiment.\nconst distance = 1.0 - similarity;\n\nif (distance > 0.4) { // Threshold for a significant shift\n    addTag(""Semantic Shift"");\n    createNote(`A significant semantic shift was detected (distance from recent history: ${distance.toFixed(2)}).`);\n}"
"18","Legal Element Mapper","Az <hereliesaz@gmail.com>","Tries to map evidence to the specific legal elements of an allegation. For example, for ""Breach of Contract"", it looks for evidence of an offer, acceptance, and a breach.","if (case.allegations.includes(""Breach of Contract"")) {\n    if (evidence.text.toLowerCase().includes(""i accept your offer"")) {\n        addTag(""Contract - Acceptance"");\n    }\n    if (evidence.text.toLowerCase().includes(""failed to deliver"")) {\n        addTag(""Contract - Breach"");\n    }\n}"
"19","Evidence Gap Suggester","Az <hereliesaz@gmail.com>","A smart script that suggests what evidence might be missing.","if (evidence.tags.includes(""Mentioned Document"")) {\n    const docName = evidence.text.match(/\\b(contract|agreement|etc)\\b/i)[0];\n    const hasDocument = case.evidence.some(e => e.metadata.type === 'document' && e.metadata.title.includes(docName));\n    if (!hasDocument) {\n        createNote(`Missing Evidence: The '${docName}' mentioned here has not been added to the case.`);\n    }\n}"
"20","Narrative Summary Generator","Az <hereliesaz@gmail.com>","The ultimate script. For a given allegation, it pulls all linked evidence and attempts to create a chronological summary of events.","// This is highly conceptual\nif (case.allegations.includes(""Harassment"")) {\n    const harassmentEvidence = case.evidence\n        .filter(e => e.allegations.includes(""Harassment""))\n        .sort((a, b) => new Date(a.metadata.date) - new Date(b.metadata.date));\n\n    let summary = ""Summary of Harassment:\\n"";\n    harassmentEvidence.forEach(e => {\n        summary += `- On ${e.metadata.date}, a message containing '${e.tags.join(', ')}' was received.\\n`;\n    });\n\n    // In a real scenario, this would be saved to a case summary file or note.\n    // For now, we'll add a note to the last piece of evidence.\n    if (evidence.id === harassmentEvidence.slice(-1)[0].id) {\n        createNote(summary);\n    }\n}"
"21","Chain of Custody Verifier","Az <hereliesaz@gmail.com>","For evidence that has been handled by multiple people, this script checks for a complete chain of custody log in the evidence's notes or metadata. It flags any evidence with gaps.","// Assumes a metadata field `evidence.metadata.custodyLog` which is an array of transfer records.\nif (evidence.metadata.type === 'physical') {\n    const log = evidence.metadata.custodyLog;\n    if (!log || log.length === 0) {\n        addTag(""Missing Chain of Custody"");\n        createNote(""Critical: Physical evidence is missing its chain of custody log."");\n        return;\n    }\n    for (let i = 0; i < log.length - 1; i++) {\n        if (log[i].toPerson !== log[i+1].fromPerson) {\n            addTag(""Broken Chain of Custody"");\n            createNote(`Chain of custody broken between ${log[i].toPerson} and ${log[i+1].fromPerson}.`);\n            setSeverity(""Critical"");\n        }\n    }\n}"
"22","Metadata Anomaly Detector","Az <hereliesaz@gmail.com>","Scans for suspicious metadata, like a photo's EXIF data showing a date that contradicts the user-provided date, or a file that has been modified after it was supposedly collected.","// Assumes EXIF data is parsed into `evidence.metadata.exif`\nif (evidence.metadata.exif && evidence.metadata.exif.dateCreated) {\n    const exifDate = new Date(evidence.metadata.exif.dateCreated);\n    const providedDate = new Date(evidence.metadata.date);\n    const diffDays = Math.abs(exifDate - providedDate) / (1000 * 3600 * 24);\n    if (diffDays > 1) {\n        addTag(""Metadata Anomaly"");\n        createNote(`EXIF creation date (${exifDate.toDateString()}) differs from provided date (${providedDate.toDateString()}).`);\n        setSeverity(""High"");\n    }\n}"
"23","Duplicate Evidence Finder","Az <hereliesaz@gmail.com>","Uses a perceptual hash (phash) or simple checksum stored in metadata to find duplicate or near-duplicate images, even if they have different filenames.","// Assumes a metadata field `evidence.metadata.phash`\nif (evidence.metadata.phash) {\n    const duplicates = case.evidence.filter(e =>\n        e.id !== evidence.id && e.metadata.phash === evidence.metadata.phash\n    );\n    if (duplicates.length > 0) {\n        addTag(""Duplicate"");\n        createNote(`This is a duplicate of evidence: ${duplicates.map(d => d.id).join(', ')}.`);\n    }\n}"
"24","Communication Style Analyzer","Az <hereliesaz@gmail.com>","Analyzes the linguistic style (e.g., sentence length, word choice, use of emojis) of a piece of evidence and compares it to the author's known baseline. Flags messages that may have been written by someone else.","// Conceptual - requires a baseline profile for the author.\n// `profile.authors['JohnDoe'].avgSentenceLength`\nconst sentences = evidence.text.split(/[.!?]+/);\nconst avgLength = evidence.text.length / sentences.length;\nconst authorProfile = profile.authors[evidence.metadata.author];\nif (authorProfile && Math.abs(avgLength - authorProfile.avgSentenceLength) > 10) {\n    addTag(""Atypical Style"");\n    createNote(""Communication style is inconsistent with author's baseline."");\n}"
"25","Automated Deposition Question Generator","Az <hereliesaz@gmail.com>","When it finds a contradiction or a threat, this script automatically generates a potential deposition question and adds it to a case-wide ""Deposition Prep"" note.","function addDepoQuestion(question) {\n    // This function would append to a central case note or task list.\n    console.log(`New Depo Question: ${question}`);\n}\n\nif (evidence.tags.includes(""Contradiction"")) {\n    addDepoQuestion(`On [Date], you stated X. However, on [Other Date], you stated Y. Can you explain this discrepancy?`);\n}\nif (evidence.tags.includes(""Threat"")) {\n    addDepoQuestion(`Can you explain what you meant when you wrote, ""${evidence.text}""?`);\n}"
"26","Expert Witness Recommender","Az <hereliesaz@gmail.com>","Based on the content of the evidence, this script suggests when an expert witness might be needed.","const financialRegex = /\\b(forensic accounting|tax fraud|embezzlement)\\b/i;\nconst techRegex = /\\b(encryption|hacking|IP address|metadata)\\b/i;\n\nif (financialRegex.test(evidence.text)) {\n    addTag(""Expert Witness Needed"");\n    createNote(""Consider engaging a forensic accountant for this evidence."");\n}\nif (techRegex.test(evidence.text)) {\n    addTag(""Expert Witness Needed"");\n    createNote(""Consider engaging a digital forensics expert for this evidence."");\n}"
"27","Automatic Redaction Suggester","Az <hereliesaz@gmail.com>","Identifies Personally Identifiable Information (PII) like social security numbers, bank account numbers, or home addresses and tags them for redaction before sharing.","const ssnRegex = /\\b\\d{3}-\\d{2}-\\d{4}\\b/;\nconst bankAccountRegex = /\\b\\d{10,16}\\b/;\nif (ssnRegex.test(evidence.text) || bankAccountRegex.test(evidence.text)) {\n    addTag(""Redact PII"");\n    setSeverity(""High"");\n}"
"28","Settlement Offer Analyzer","Az <hereliesaz@gmail.com>","When a settlement offer is mentioned, this script scours the case for all evidence tagged ""Financial"" and calculates a running total of claimed damages to provide context for the offer.","const offerRegex = /i will offer you \\$([\\d,.]+)/i;\nconst match = evidence.text.match(offerRegex);\nif (match) {\n    const offerAmount = parseFloat(match[1].replace(/,/g, ''));\n    addTag(""Settlement Offer"");\n\n    let totalDamages = 0;\n    const financialEvidence = case.evidence.filter(e => e.tags.includes(""Financial""));\n    financialEvidence.forEach(e => {\n        const damageMatch = e.text.match(/you owe me \\$([\\d,.]+)/i);\n        if (damageMatch) {\n            totalDamages += parseFloat(damageMatch[1].replace(/,/g, ''));\n        }\n    });\n\n    createNote(`Settlement offer of $${offerAmount} received. Total calculated damages in case: $${totalDamages}.`);\n}"
"29","Cross-Case Actor Linker","Az <hereliesaz@gmail.com>","Identifies if an actor (e.g., a person, a company) in this case has appeared in any other case in your database. Requires a global case database API.","// Conceptual - requires a global `database` object.\nconst actorName = evidence.metadata.author;\nconst otherCases = database.findCasesByActor(actorName);\nif (otherCases.length > 0) {\n    addTag(""Cross-Case Link"");\n    createNote(`Actor ${actorName} also appears in cases: ${otherCases.map(c => c.name).join(', ')}.`);\n}"
"30","Legal Precedent Suggester (Functional)","Az <hereliesaz@gmail.com>","Identifies when evidence is semantically similar to complex legal concepts, suggesting topics for precedent research.","// This script compares evidence against a predefined list of complex legal concepts\n// and suggests topics for further research if a strong semantic match is found.\nconst legalConcepts = [\n    { name: ""Economic Abuse"", description: ""Controlling a person's ability to acquire, use, and maintain financial resources."" },\n    { name: ""Coercive Control"", description: ""A pattern of intimidation, degradation, isolation, and control used to harm or frighten someone."" },\n    { name: ""Promissory Estoppel"", description: ""A legal principle that a promise is enforceable by law, even if made without formal consideration, when a party relies on that promise to their detriment."" },\n    { name: ""Constructive Fraud"", description: ""An act that is considered fraudulent under the law even without intent to deceive, such as a breach of a legal or equitable duty."" }\n];\n\nconst evidenceText = evidence.text;\nlet suggestions = [];\n\nlegalConcepts.forEach(concept => {\n    const similarity = lex.ai.local.calculateSimilarity(evidenceText, concept.description);\n    if (similarity > 0.65) { // Confidence threshold\n        suggestions.push(concept.name);\n    }\n});\n\nif (suggestions.length > 0) {\n    addTag(""Legal Research Suggested"");\n    createNote(`This evidence shows semantic similarity to the following legal concepts: ${suggestions.join(', ')}. Consider researching relevant precedents.`);\n}"
"31","""Smoking Gun"" Identifier","Az <hereliesaz@gmail.com>","This script combines multiple high-value indicators to flag a piece of evidence as a potential ""smoking gun"".","let score = 0;\nif (evidence.tags.includes(""Admission"")) score++;\nif (evidence.tags.includes(""Contradiction"")) score++;\nif (evidence.metadata.severity === ""Critical"") score++;\nif (evidence.tags.includes(""Atypical Style"")) score++; // Suggests someone trying to hide\n\nif (score >= 3) {\n    addTag(""Smoking Gun?"");\n    setSeverity(""Critical"");\n    createNote(""This evidence has multiple high-value indicators. Prioritize for review."");\n}"
"32","Case Strength Barometer","Az <hereliesaz@gmail.com>","A meta-script that runs periodically over the whole case, assessing the ratio of evidence linked to allegations vs. unlinked evidence, and the number of ""Smoking Gun"" or ""Critical"" items, to provide a rough barometer of case strength.","// This would likely be a standalone script run on the case object, not on a single piece of evidence.\nconst linkedEvidence = case.evidence.filter(e => e.allegations.length > 0).length;\nconst totalEvidence = case.evidence.length;\nconst strengthRatio = linkedEvidence / totalEvidence;\nconst criticalItems = case.evidence.filter(e => e.metadata.severity === ""Critical"").length;\n\nlet strength = ""Weak"";\nif (strengthRatio > 0.5) strength = ""Moderate"";\nif (strengthRatio > 0.75) strength = ""Strong"";\nif (criticalItems > 2) strength = ""Very Strong"";\n\ncreateNote(`Case Strength Barometer: ${strength} (Ratio: ${strengthRatio.toFixed(2)}, Critical Items: ${criticalItems})`);"
"33","Opposing Counsel Strategy Predictor (Functional)","Az <hereliesaz@gmail.com>","Based on the patterns of tags across all evidence, this script predicts the opposing counsel's likely defense strategy.","// This script looks for patterns in the tags of all evidence to predict the opponent's strategy.\n// It relies on other scripts (like #8 Admission of Guilt and #63 Semantic Gaslighting Detector) having run first.\nconst hasSemanticGaslighting = case.evidence.some(e => e.tags.includes(""Gaslighting (Semantic)""));\nconst hasAdmission = case.evidence.some(e => e.tags.includes(""Admission""));\n\nlet prediction = null;\n\nif (hasSemanticGaslighting && !hasAdmission) {\n    prediction = ""Opposing counsel will likely attack the victim's credibility and state of mind ('unstable' defense)."";\n} else if (hasAdmission && !hasSemanticGaslighting) {\n    prediction = ""Opposing counsel may attempt a 'remorse' defense or argue admissions were taken out of context or coerced."";\n} else if (hasSemanticGaslighting && hasAdmission) {\n    prediction = ""Opposing counsel faces a difficult case. They may try to minimize the admissions and paint the gaslighting as simple disagreements."";\n}\n\nif (prediction) {\n    createNote(`Predicted Opposing Strategy: ${prediction}`);\n    addTag(""Strategy Prediction"");\n}"
"34","Missing Narrative Link Detector","Az <hereliesaz@gmail.com>","Analyzes the timeline of events and points out logical gaps where evidence should exist but doesn't.","// Conceptual AI\nconst threat = case.evidence.find(e => e.tags.includes(""Threat""));\nif (threat) {\n    const followUp = case.evidence.find(e => new Date(e.metadata.date) > new Date(threat.metadata.date));\n    if (!followUp) {\n        createNote(""Narrative Gap: A threat was made, but there is no subsequent evidence showing the outcome or de-escalation. What happened next?"");\n    }\n}"
"35","Evidence Forgery Risk Assessor","Az <hereliesaz@gmail.com>","Uses a conceptual AI model to analyze an image for signs of digital manipulation (e.g., inconsistent compression levels, pixel anomalies).","// Conceptual AI\nif (evidence.metadata.type === 'image') {\n    const forgeryRisk = ForgeryDetectionAI.analyze(evidence.imagePath); // returns a score 0-1\n    if (forgeryRisk > 0.8) {\n        addTag(""Forgery Risk"");\n        setSeverity(""Critical"");\n        createNote(`AI analysis indicates a ${forgeryRisk*100}% risk of digital manipulation.`);\n    }\n}"
"36","Automated Witness Vetting","Az <hereliesaz@gmail.com>","When a potential witness is identified, this script could (with permission) run a conceptual background check API to look for public records, conflicts of interest, or past instances of perjury.","// Conceptual API\nif (evidence.tags.some(t => t.startsWith(""Potential Witness:""))) {\n    const witnessName = evidence.tags.find(t => t.startsWith(""Potential Witness:"")).split("": "")[1];\n    const backgroundCheck = BackgroundCheckAPI.run(witnessName);\n    if (backgroundCheck.hasRedFlags) {\n        createNote(`Witness Vetting: ${witnessName} has potential red flags: ${backgroundCheck.flags.join(', ')}.`);\n    }\n}"
"37","Auto-Categorize & File Evidence","Az <hereliesaz@gmail.com>","An AI-powered script that reads the evidence and automatically files it under the most relevant allegation without needing explicit rules.","// Conceptual AI\nconst textToClassify = evidence.text;\nconst allAllegations = case.allegations;\nconst bestFitAllegation = ClassificationAI.findBestMatch(textToClassify, allAllegations);\nif (bestFitAllegation.confidence > 0.7) {\n    linkToAllegation(bestFitAllegation.name);\n}"
"38","Dynamic Discovery Request Drafter","Az <hereliesaz@gmail.com>","Goes beyond suggesting requests. This script would actually draft a formal discovery request document based on the gaps it has identified.","// Conceptual Document Generation\nif (evidence.tags.includes(""Missing Evidence"")) {\n    const missingDoc = evidence.notes.find(n => n.startsWith(""Missing Evidence:"")).split(""'""[1];\n    const requestDraft = DocumentGenerator.create('DiscoveryRequest', {\n        itemNumber: 1,\n        description: `All documents relating to the '${missingDoc}' mentioned in the communication dated ${evidence.metadata.date}.`\n    });\n    // save requestDraft to case files\n}"
"39","Case Outcome Predictor","Az <hereliesaz@gmail.com>","The holy grail. A conceptual AI that analyzes all evidence, case strength, linked precedents, and opposing counsel strategy to provide a probabilistic outcome prediction.","// Conceptual AI\nconst prediction = OutcomePredictionAI.analyze(case);\n// prediction = { outcome: ""Favorable Settlement"", confidence: 0.65, keyFactors: [""Smoking Gun evidence"", ""Strong witness list""] }\ncreateNote(`Outcome Prediction: ${prediction.outcome} (Confidence: ${prediction.confidence*100}%) based on: ${prediction.keyFactors.join(', ')}.`);"
"40","Automated Case Summary & Brief Generation","Az <hereliesaz@gmail.com>","A final, generative script that takes the narrative summaries, key evidence, witness lists, and legal precedents and generates a first draft of a case brief or summary judgment motion.","// Conceptual Document Generation\nif (case.status === ""Preparing for Trial"") {\n    const caseBriefDraft = DocumentGenerator.create('CaseBrief', {\n        caseObject: case\n    });\n    // save caseBriefDraft to case files\n    createNote(""First draft of the case brief has been generated based on the current state of the case."");\n}"
"41","AI-Powered Evidence Summarization","Az <hereliesaz@gmail.com>","Calls an AI model to generate a concise, neutral summary of a long piece of evidence and writes it to a ""Summary"" column in the ""Evidence"" sheet.","const longText = evidence.text;\nif (longText.length > 2000) { // Only summarize long texts\n    const summary = AI.analyze(""Summarizer"", { text: longText });\n    const evidenceRow = Spreadsheet.query(""Evidence"", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\n    Spreadsheet.updateCell(""Evidence"", `H${evidenceRow.rowNumber}`, summary.text); // Assuming H is the Summary column\n}"
"42","Key Entity Extraction to Spreadsheet","Az <hereliesaz@gmail.com>","Uses an AI to extract all named entities (People, Places, Organizations, Dates) and populates a new ""Entities"" sheet with the entity, its type, and a link back to the source evidence.","Spreadsheet.createSheet(""Entities""); // Fails silently if it exists\nconst entities = AI.analyze(""EntityExtractor"", { text: evidence.text });\nentities.forEach(entity => {\n    Spreadsheet.appendRow(""Entities"", {\n        ""Entity"": entity.name,\n        ""Type"": entity.type,\n        ""SourceEvidenceID"": evidence.id\n    });\n});"
"43","Action Item Tracker","Az <hereliesaz@gmail.com>","An AI script that identifies action items or commitments (e.g., ""I will pay you on Friday"") and logs them in a new ""ActionItems"" sheet.","Spreadsheet.createSheet(""ActionItems"");\nconst actionItems = AI.analyze(""ActionItemFinder"", { text: evidence.text });\nactionItems.forEach(item => {\n    Spreadsheet.appendRow(""ActionItems"", {\n        ""Commitment"": item.commitment,\n        ""DueDate"": item.dueDate, // The AI would extract this\n        ""SourceEvidenceID"": evidence.id\n    });\n});"
"44","De-identify and Anonymize to Column","Az <hereliesaz@gmail.com>","Uses an AI to find and replace all PII, saving this anonymized version to a new ""AnonymizedText"" column in the spreadsheet for safe sharing.","const anonymized = AI.analyze(""Anonymizer"", { text: evidence.text });\nconst evidenceRow = Spreadsheet.query(""Evidence"", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\nSpreadsheet.updateCell(""Evidence"", `I${evidenceRow.rowNumber}`, anonymized.text); // Assuming I is the AnonymizedText column"
"45","Advanced Emotion & Intent Analysis (Functional)","Az <hereliesaz@gmail.com>","Analyzes text for nuanced emotions and perceived intent by comparing it to a list of example sentences.","// This script attempts to classify the primary emotion and intent behind a piece\n// of evidence by comparing it to text samples representing different categories.\nconst emotionSamples = [\n    { name: ""Anger"", text: ""I am furious about this, you will regret it."" },\n    { name: ""Fear"", text: ""I am scared of what might happen next, please be careful."" },\n    { name: ""Sadness"", text: ""This whole situation just makes me incredibly sad and hopeless."" }\n];\n\nconst intentSamples = [\n    { name: ""Deceptive"", text: ""That's not what I said, you must have misunderstood me completely."" },\n    { name: ""Conciliatory"", text: ""I understand your position and I want to find a way to make this right."" },\n    { name: ""Threatening"", text: ""You should really think about what you're doing, there will be consequences."" }\n];\n\nconst evidenceText = evidence.text;\n\n// Find best emotion match\nlet bestEmotion = { name: null, similarity: -1.0 };\nemotionSamples.forEach(sample => {\n    const similarity = lex.ai.local.calculateSimilarity(evidenceText, sample.text);\n    if (similarity > bestEmotion.similarity) {\n        bestEmotion = { name: sample.name, similarity: similarity };\n    }\n});\n\n// Find best intent match\nlet bestIntent = { name: null, similarity: -1.0 };\nintentSamples.forEach(sample => {\n    const similarity = lex.ai.local.calculateSimilarity(evidenceText, sample.text);\n    if (similarity > bestIntent.similarity) {\n        bestIntent = { name: sample.name, similarity: similarity };\n    }\n});\n\nif (bestEmotion.name && bestEmotion.similarity > 0.5) {\n    addTag(`Emotion: ${bestEmotion.name}`);\n}\nif (bestIntent.name && bestIntent.similarity > 0.5) {\n    addTag(`Intent: ${bestIntent.name}`);\n}"
"46","Legal Topic Classification","Az <hereliesaz@gmail.com>","Classifies evidence into specific legal topics, allowing for powerful filtering in the spreadsheet.","const topic = AI.analyze(""LegalTopicClassifier"", { text: evidence.text });\nconst row = Spreadsheet.query(""Evidence"", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\nSpreadsheet.updateCell(""Evidence"", `L${row.rowNumber}`, topic.name); // e.g., ""Contract Law"""
"47","Evidence Admissibility Score","Az <hereliesaz@gmail.com>","Assesses evidence against rules of evidence (hearsay, relevance) and adds a preliminary ""Admissibility Score"" and reasoning to the spreadsheet.","const admissibility = AI.analyze(""AdmissibilityScorer"", { text: evidence.text, metadata: evidence.metadata });\nconst row = Spreadsheet.query(""Evidence"", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\nSpreadsheet.updateCell(""Evidence"", `M${row.rowNumber}`, admissibility.score); // e.g., 0.75\nSpreadsheet.updateCell(""Evidence"", `N${row.rowNumber}`, admissibility.reasoning);"
"48","Argument Strength Assessor","Az <hereliesaz@gmail.com>","When evidence is linked to an allegation, this AI evaluates how strongly the evidence supports it, providing a score and explanation in a ""SupportStrength"" column.","if (evidence.allegations.length > 0) {\n    const allegationText = case.allegations.find(a => a.name === evidence.allegations[0]).description;\n    const strength = AI.analyze(""ArgumentStrength"", { premise: evidence.text, conclusion: allegationText });\n    const row = Spreadsheet.query(""Evidence"", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\n    Spreadsheet.updateCell(""Evidence"", `O${row.rowNumber}`, strength.score);\n}"
"49","Create a Dynamic Case Timeline Sheet","Az <hereliesaz@gmail.com>","Queries all evidence, sorts it by date, and uses an AI summarizer on each piece to generate a new, clean ""Timeline"" sheet.","Spreadsheet.createSheet(""Timeline"");\nconst allEvidence = Spreadsheet.query(""Evidence"", ""SELECT * ORDER BY Date ASC"");\nallEvidence.forEach(row => {\n    const summary = AI.analyze(""Summarizer"", { text: row.Text });\n    Spreadsheet.appendRow(""Timeline"", {\n        ""Date"": row.Date,\n        ""EventSummary"": summary.text,\n        ""SourceEvidenceID"": row.EvidenceID\n    });\n});"
"50","Identify Key Witnesses from Spreadsheet Data","Az <hereliesaz@gmail.com>","Queries the ""Entities"" sheet for all ""Person"" entities, counts their mentions, and creates a ""KeyWitnesses"" sheet sorted by frequency.","Spreadsheet.createSheet(""KeyWitnesses"");\nconst witnesses = Spreadsheet.query(""Entities"", ""SELECT Entity, COUNT(*) as Mentions WHERE Type = 'Person' GROUP BY Entity ORDER BY Mentions DESC"");\nwitnesses.forEach(witness => {\n    Spreadsheet.appendRow(""KeyWitnesses"", witness);\n});"
"51","AI-Generated Contradiction Matrix","Az <hereliesaz@gmail.com>","Systematically compares evidence in the spreadsheet and, if it finds a contradiction, creates a ""ContradictionMatrix"" sheet logging the conflict.","Spreadsheet.createSheet(""ContradictionMatrix"");\nconst allEvidence = Spreadsheet.query(""Evidence"", ""SELECT EvidenceID, Text"");\nfor (let i = 0; i < allEvidence.length; i++) {\n    for (let j = i + 1; j < allEvidence.length; j++) {\n        const result = AI.analyze(""ContradictionFinder"", { textA: allEvidence[i].Text, textB: allEvidence[j].Text });\n        if (result.isContradictory) {\n            Spreadsheet.appendRow(""ContradictionMatrix"", {\n                ""EvidenceID_A"": allEvidence[i].EvidenceID,\n                ""EvidenceID_B"": allEvidence[j].EvidenceID,\n                ""Explanation"": result.explanation\n            });\n        }\n    }\n}"
"52","Cluster Similar Evidence into a New Sheet","Az <hereliesaz@gmail.com>","Uses an AI embedding model to group semantically similar evidence, creating a ""Clusters"" sheet that maps each piece of evidence to a Cluster ID.","Spreadsheet.createSheet(""Clusters"");\nconst allEvidence = Spreadsheet.query(""Evidence"", ""SELECT EvidenceID, Text"");\nconst clusters = AI.analyze(""Clusterer"", { documents: allEvidence.map(e => e.Text) });\nclusters.forEach((clusterId, index) => {\n    Spreadsheet.appendRow(""Clusters"", {\n        ""EvidenceID"": allEvidence[index].EvidenceID,\n        ""ClusterID"": clusterId\n    });\n});"
"53","Generate Deposition Questions for a Witness","Az <hereliesaz@gmail.com>","Selects a witness from the ""KeyWitnesses"" sheet, queries all associated evidence, and uses a generative AI to create tailored deposition questions in a new sheet.","const topWitness = Spreadsheet.query(""KeyWitnesses"", ""SELECT Entity LIMIT 1"")[0].Entity;\nSpreadsheet.createSheet(`DepoPrep_${topWitness}`);\nconst relatedEvidence = Spreadsheet.query(""Entities"", `SELECT SourceEvidenceID WHERE Entity = '${topWitness}'`);\nconst texts = relatedEvidence.map(e => Spreadsheet.query(""Evidence"", `SELECT Text WHERE EvidenceID = '${e.SourceEvidenceID}'`)[0].Text);\n\nconst questions = AI.analyze(""DepoQuestionGenerator"", { context: texts.join(""\\n\\n"") });\nquestions.forEach(q => {\n    Spreadsheet.appendRow(`DepoPrep_${topWitness}`, { ""Question"": q });\n});"
"54","Predict Missing Document Types","Az <hereliesaz@gmail.com>","The AI analyzes existing documents and communications in the spreadsheet to predict what standard documents are likely missing, logging them in a ""DiscoveryGaps"" sheet.","Spreadsheet.createSheet(""DiscoveryGaps"");\nconst allText = Spreadsheet.query(""Evidence"", ""SELECT Text"").map(r => r.Text).join(""\\n"");\nconst missingDocs = AI.analyze(""MissingDocumentPredictor"", { context: allText, caseType: case.type });\nmissingDocs.forEach(doc => {\n    Spreadsheet.appendRow(""DiscoveryGaps"", { ""SuggestedMissingDocument"": doc });\n});"
"55","Financial Anomaly Detection in Transactions","Az <hereliesaz@gmail.com>","If the spreadsheet has a ""Transactions"" sheet, this AI script analyzes it for anomalies, flagging them for review in a new ""FlaggedTransactions"" sheet.","Spreadsheet.createSheet(""FlaggedTransactions"");\nconst transactions = Spreadsheet.query(""Transactions"", ""SELECT *"");\nconst flagged = AI.analyze(""FinancialAnomalyDetector"", { transactions: transactions });\nflagged.forEach(txn => {\n    Spreadsheet.appendRow(""FlaggedTransactions"", { ...txn, ""Reason"": ""AI Flagged"" });\n});"
"56","Draft a Case Summary from Spreadsheet Data","Az <hereliesaz@gmail.com>","An AI script that reads multiple sheets (Evidence, Timeline, Allegations) to generate a narrative first draft of a case summary, writing it to a ""CaseSummary"" sheet.","Spreadsheet.createSheet(""CaseSummary"");\nconst context = {\n    allegations: Spreadsheet.query(""Allegations"", ""SELECT *""),\n    timeline: Spreadsheet.query(""Timeline"", ""SELECT *""),\n    keyEvidence: Spreadsheet.query(""Evidence"", ""SELECT * WHERE Severity = 'Critical'""\n};\nconst summary = AI.analyze(""CaseSummaryGenerator"", { context: context });\nSpreadsheet.appendRow(""CaseSummary"", { ""GeneratedSummary"": summary.text });"
"57","""What-If"" Scenario Analysis","Az <hereliesaz@gmail.com>","A user adds hypothetical evidence to a ""WhatIf"" sheet. This script uses an AI to predict its impact on the case, writing the analysis back to the sheet.","const scenarios = Spreadsheet.query(""WhatIf"", ""SELECT * WHERE Analysis IS NULL"");\nscenarios.forEach(scenario => {\n    const impact = AI.analyze(""ImpactPredictor"", { case: case, newEvidence: scenario.HypotheticalEvidence });\n    Spreadsheet.updateCell(""WhatIf"", `B${scenario.rowNumber}`, impact.analysis); // Assuming B is Analysis column\n});"
"58","Auto-Update Allegation Status in Spreadsheet","Az <hereliesaz@gmail.com>","Periodically reviews all evidence linked to an allegation and, if sufficiently supported, updates a ""Status"" column for that allegation in the ""Allegations"" sheet.","const allegations = Spreadsheet.query(""Allegations"", ""SELECT *"");\nallegations.forEach(allegation => {\n    const relatedEvidence = Spreadsheet.query(""Evidence"", `SELECT * WHERE allegations LIKE '%${allegation.Name}%'`);\n    const strength = AI.analyze(""AllegationStrength"", { evidence: relatedEvidence });\n    if (strength.score > 0.8) {\n        Spreadsheet.updateCell(""Allegations"", `C${allegation.rowNumber}`, ""Sufficiently Supported""); // C is Status column\n    }\n});"
"59","Identify the ""Most Persuasive"" Evidence","Az <hereliesaz@gmail.com>","An AI ranks all evidence in the spreadsheet based on relevance, admissibility, and impact, then creates a ""Top5Evidence"" sheet with links to these key pieces.","Spreadsheet.createSheet(""Top5Evidence"");\nconst allEvidence = Spreadsheet.query(""Evidence"", ""SELECT *"");\nconst rankings = AI.analyze(""PersuasivenessRanker"", { evidence: allEvidence, allegations: case.allegations });\nrankings.slice(0, 5).forEach(item => {\n    Spreadsheet.appendRow(""Top5Evidence"", { ""EvidenceID"": item.id, ""Rank"": item.rank, ""Reason"": item.reason });\n});"
"60","AI-Powered Spreadsheet Query via Natural Language","Az <hereliesaz@gmail.com>","A user writes a question in a ""Queries"" sheet. The script sends it to an AI that converts it into a formal query, executes it, and pastes the results into the sheet.","const newQueries = Spreadsheet.query(""Queries"", ""SELECT * WHERE Result IS NULL"");\nnewQueries.forEach(query => {\n    const formalQuery = AI.analyze(""NLQtoSQL"", { question: query.Question });\n    try {\n        const results = Spreadsheet.query(formalQuery.sheet, formalQuery.sql);\n        const resultsAsText = JSON.stringify(results, null, 2);\n        Spreadsheet.updateCell(""Queries"", `B${query.rowNumber}`, resultsAsText);\n    } catch (e) {\n        Spreadsheet.updateCell(""Queries"", `B${query.rowNumber}`, `Error: ${e.message}`);\n    }\n});"
"61","Semantic Gaslighting Detector (Functional)","Az <hereliesaz@gmail.com>","This script uses semantic similarity to detect phrases that are variations of gaslighting, even if they don't use the exact keywords from a predefined list.","const gaslightingExamples = [\n    ""You are being irrational and overly emotional."",\n    ""That is not what happened, you are remembering it wrong."",\n    ""I was just joking, you are too sensitive."",\n    ""You are making a big deal out of nothing."",\n    ""I am sorry you feel that way.""""\n];\nconst evidenceText = evidence.text;\nlet isGaslighting = false;\ngaslightingExamples.forEach(example => {\n    if (lex.ai.local.calculateSimilarity(evidenceText, example) > 0.7) {\n        isGaslighting = true;\n    }\n});\nif (isGaslighting) {\n    addTag(""Gaslighting (Semantic)"");\n    linkToAllegation(""Emotional Abuse"");\n}"
"62","Simple Tutorial: ""Hello, Dynamic Screens!""","Az <hereliesaz@gmail.com>","This script demonstrates the most basic use of the `lex.ui` object. It creates a new, clickable menu item in the main navigation rail. When you click this item, it opens a brand new screen that is completely defined by a JSON schema within the script.","const myScreenSchema = {\n  title: ""Hello World"",\n  elements: [\n    { type: ""text"", properties: { text: ""Welcome to your first scripted screen!"", size: 20 } },\n    { type: ""spacer"", properties: { height: 16 } },\n    { type: ""button"", properties: { label: ""Say Hello"", onClickAction: ""show_toast:Hello from a scripted button!"" } }\n  ]\n};\nlex.ui.addOrUpdate(""my_first_screen_button"", ""My Screen"", true, ""scripted_screen/"" + JSON.stringify(myScreenSchema));"
"63","Advanced Tutorial: AI-Powered In-App Guide","Az <hereliesaz@gmail.com>","This script demonstrates combining the AI and UI APIs. It creates a ""Tutorial & Tip"" menu item that opens a custom screen featuring a ""Tip of the Day"" freshly generated by the AI.","const tipPrompt = ""In one sentence, give me a useful and uncommon productivity tip for legal professionals."";\n// Note: This uses the cloud-based generative AI, not the local one.\nconst aiGeneratedTip = lex.ai.generate.generateContent(tipPrompt);\nconst tutorialSchema = {\n  title: ""App Tutorial"",\n  elements: [\n    { type: ""text"", properties: { text: ""Welcome to The Lexorcist!"", size: 24 } },\n    { type: ""text"", properties: { text: ""This app helps you organize, analyze, and build your case narrative."", size: 16 } },\n    { type: ""spacer"", properties: { height: 24 } },\n    { type: ""text"", properties: { text: ""AI Tip of the Day:"", size: 20 } },\n    { type: ""text"", properties: { text: aiGeneratedTip, size: 16 } },\n    { type: ""spacer"", properties: { height: 24 } },\n    { type: ""text"", properties: { text: ""Use the navigation rail on the left to manage Cases, Evidence, and more."", size: 16 } }\n  ]\n};\nlex.ui.addOrUpdate(""ai_tutorial_screen_button"", ""Tutorial & Tip"", true, ""scripted_screen/"" + JSON.stringify(tutorialSchema));"