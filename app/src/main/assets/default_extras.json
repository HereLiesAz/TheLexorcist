{
  "scripts": [
    {
      "name": "1. Profanity Tagger",
      "author": "Az",
      "description": "A simple script to tag any evidence containing common curse words. Useful for establishing a general tone of communication.",
      "content": "const curses = [\"f***\", \"s***\", \"b****\", \"a******\"];\nconst text = evidence.text.toLowerCase();\nif (curses.some(word => text.includes(word))) {\n    addTag(\"Profanity\");\n}"
    },
    {
      "name": "2. Financial Transaction Tagger",
      "author": "Az",
      "description": "Identifies and tags any mention of money or financial transactions.",
      "content": "const financialRegex = /[$€£¥]|\\b(dollar|euro|yen|pound|payment|paid|owe|money)\\b/i;\nif (financialRegex.test(evidence.text)) {\n    addTag(\"Financial\");\n}"
    },
    {
      "name": "3. Contact Information Extractor",
      "author": "Az",
      "description": "Finds and tags phone numbers and email addresses, making it easy to find contact details later.",
      "content": "const emailRegex = /\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b/i;\nconst phoneRegex = /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/;\nif (emailRegex.test(evidence.text)) {\n    addTag(\"Email Address\");\n}\nif (phoneRegex.test(evidence.text)) {\n    addTag(\"Phone Number\");\n}"
    },
    {
      "name": "4. Appointment & Deadline Tagger",
      "author": "Az",
      "description": "Scans for mentions of specific dates, appointments, or deadlines.",
      "content": "const deadlineRegex = /\\b(appointment|meeting|deadline|due on|court date)\\b/i;\nif (deadlineRegex.test(evidence.text)) {\n    addTag(\"Deadline/Appointment\");\n}"
    },
    {
      "name": "5. Gaslighting Detector",
      "author": "Az",
      "description": "Identifies phrases commonly used in gaslighting to deny a person's reality.",
      "content": "const gaslightingPhrases = [\"you're crazy\", \"that never happened\", \"you're imagining things\", \"you're too sensitive\", \"I never said that\"];\nconst text = evidence.text.toLowerCase();\nif (gaslightingPhrases.some(phrase => text.includes(phrase))) {\n    addTag(\"Gaslighting\");\n    linkToAllegation(\"Emotional Abuse\");\n}"
    },
    {
      "name": "6. Threat Severity Assessor",
      "author": "Az",
      "description": "A more nuanced threat detector that assigns a severity level based on the type of threat.",
      "content": "const lowSeverity = [\"i'll make you pay\"];\nconst medSeverity = [\"i'll ruin your life\"];\nconst highSeverity = [\"i'm going to hurt you\", \"i'll kill you\"];\nconst text = evidence.text.toLowerCase();\n\nif (highSeverity.some(p => text.includes(p))) {\n    addTag(\"Threat\");\n    setSeverity(\"Critical\");\n} else if (medSeverity.some(p => text.includes(p))) {\n    addTag(\"Threat\");\n    setSeverity(\"High\");\n} else if (lowSeverity.some(p => text.includes(p))) {\n    addTag(\"Threat\");\n    setSeverity(\"Medium\");\n}"
    },
    {
      "name": "7. Custody Violation Tagger",
      "author": "Az",
      "description": "Specifically for family law cases, this script looks for violations of custody agreements.",
      "content": "const violationPhrases = [\"you can't see the kids\", \"i'm not bringing him back\", \"it's not your weekend\"];\nif (violationPhrases.some(p => evidence.text.toLowerCase().includes(p))) {\n    addTag(\"Custody Violation\");\n    linkToAllegation(\"Child Custody Interference\");\n}"
    },
    {
      "name": "8. Admission of Guilt Detector",
      "author": "Az",
      "description": "Flags phrases that could be interpreted as an admission of wrongdoing.",
      "content": "const admissionPhrases = [\"i know i messed up\", \"it was my fault\", \"i'm sorry i did that\", \"i shouldn't have\"];\nif (admissionPhrases.some(p => evidence.text.toLowerCase().includes(p))) {\n    addTag(\"Admission\");\n}"
    },
    {
      "name": "9. Stalking Pattern Detector",
      "author": "Az",
      "description": "This script looks for patterns of stalking by correlating location mentions across multiple pieces of evidence.",
      "content": "const locationRegex = /i saw you at (.+?)\\b/i;\nconst match = evidence.text.match(locationRegex);\nif (match) {\n    const location = match[1];\n    addTag(`Location Mention: ${location}`);\n    const otherMentions = case.evidence.filter(e =>\n        e.tags.some(t => t.startsWith(\"Location Mention:\"))\n    );\n    if (otherMentions.length > 2) {\n        addTag(\"Stalking Pattern\");\n        linkToAllegation(\"Stalking\");\n        createNote(`Multiple uninvited location mentions detected. Potential stalking behavior.`);\n    }\n}"
    },
    {
      "name": "10. Contradiction Finder",
      "author": "Az",
      "description": "Scans other evidence to find direct contradictions.",
      "content": "const promiseRegex = /i promise to (pay you|give you)(.+?)\\b/i;\nconst denialRegex = /i never promised to (pay you|give you)(.+?)\\b/i;\n\nconst promiseMatch = evidence.text.match(promiseRegex);\nif (promiseMatch) {\n    const promisedItem = promiseMatch[2].trim();\n    const contradiction = case.evidence.find(e => {\n        const denialMatch = e.text.match(denialRegex);\n        return denialMatch && denialMatch[2].trim() === promisedItem;\n    });\n    if (contradiction) {\n        addTag(\"Contradiction\");\n        createNote(`This contradicts evidence from ${contradiction.metadata.date}.`);\n    }\n}"
    },
    {
      "name": "11. Escalation Tracker",
      "author": "Az",
      "description": "Tracks the severity of threats over time to show a pattern of escalation.",
      "content": "if (evidence.tags.includes(\"Threat\")) {\n    const pastThreats = case.evidence.filter(e =>\n        e.tags.includes(\"Threat\") && new Date(e.metadata.date) < new Date(evidence.metadata.date)\n    );\n    const pastSeverity = pastThreats.map(e => e.metadata.severity);\n    if (pastSeverity.includes(\"Medium\") && evidence.metadata.severity === \"High\") {\n        addTag(\"Escalating Behavior\");\n        createNote(\"Severity has escalated from Medium to High.\");\n    }\n}"
    },
    {
      "name": "12. Alibi Corroborator/Breaker",
      "author": "Az",
      "description": "Checks for consistencies or inconsistencies in alibis.",
      "content": "const alibiRegex = /i was at (.+?) at (\\d{1,2}:\\d{2}[ap]m)/i;\nconst match = evidence.text.match(alibiRegex);\nif (match) {\n    const location = match[1];\n    const time = match[2];\n    addTag(`Alibi: ${location} at ${time}`);\n    const conflictingEvidence = case.evidence.find(e =>\n        e.text.includes(`i saw you at a different place at ${time}`)\n    );\n    if (conflictingEvidence) {\n        addTag(\"Alibi Conflict\");\n    }\n}"
    },
    {
      "name": "13. Third-Party Witness Identifier",
      "author": "Az",
      "description": "Scans for mentions of other people who could be potential witnesses.",
      "content": "const witnessRegex = /\\b(ask|talk to|with|saw|told) ([A-Z][a-z]+)\\b/g;\nlet match;\nwhile ((match = witnessRegex.exec(evidence.text)) !== null) {\n    const witnessName = match[2];\n    if (witnessName.toLowerCase() !== \"you\") {\n        addTag(`Potential Witness: ${witnessName}`);\n    }\n}"
    },
    {
      "name": "14. Document Request Generator",
      "author": "Az",
      "description": "Identifies mentions of documents that you might need to request in discovery.",
      "content": "const docRegex = /\\b(contract|agreement|lease|receipt|invoice|bank statement)\\b/ig;\nlet match;\nwhile ((match = docRegex.exec(evidence.text)) !== null) {\n    addTag(\"Mentioned Document\");\n    createNote(`Discovery suggestion: Request the '${match[0]}' mentioned here.`);\n}"
    },
    {
      "name": "15. Communication Blackout Detector",
      "author": "Az",
      "description": "Identifies sudden and prolonged gaps in communication, which can be significant.",
      "content": "const lastCommunication = case.evidence\n    .filter(e => e.metadata.source === evidence.metadata.source)\n    .sort((a, b) => new Date(b.metadata.date) - new Date(a.metadata.date))[1]; // Get the one before this one\n\nif (lastCommunication) {\n    const daysSince = (new Date(evidence.metadata.date) - new Date(lastCommunication.metadata.date)) / (1000 * 3600 * 24);\n    if (daysSince > 14) { // 2-week gap\n        addTag(\"Communication Gap\");\n        createNote(`A ${Math.round(daysSince)}-day gap in communication occurred before this message.`);\n    }\n}"
    },
    {
      "name": "16. \"If This, Then That\" Coercion Analyzer",
      "author": "Az",
      "description": "A more advanced script to detect coercive \"if-then\" statements.",
      "content": "const coercionRegex = /if you (don't|won't) (.+?), (then )?i will (.+)/i;\nconst match = evidence.text.match(coercionRegex);\nif (match) {\n    const demand = match[2];\n    const consequence = match[4];\n    addTag(\"Coercion\");\n    linkToAllegation(\"Coercion/Blackmail\");\n    createNote(`Coercive statement detected. Demand: '${demand}', Consequence: '${consequence}'.`);\n}"
    },
    {
      "name": "17. Semantic Shift Analysis (Functional)",
      "author": "Az",
      "description": "Detects a significant semantic shift in communication style or topic by comparing the current evidence to the recent history. This can indicate a change in tone, strategy, or the start of a new conflict.",
      "content": "// This script detects a significant semantic shift by comparing the current\n// evidence's meaning to the combined meaning of recent evidence.\nconst recentEvidence = case.evidence.slice(-5);\nif (recentEvidence.length < 5) {\n    // Not enough history to compare.\n    return;\n}\n\n// Create a single representative text for the recent history.\nconst recentHistoryText = recentEvidence.map(e => e.text).join(' ');\n\n// Use the efficient, native calculateSimilarity function.\nconst similarity = lex.ai.local.calculateSimilarity(evidence.text, recentHistoryText);\n\n// A low similarity (high distance) indicates a shift in topic or sentiment.\nconst distance = 1.0 - similarity;\n\nif (distance > 0.4) { // Threshold for a significant shift\n    addTag(\"Semantic Shift\");\n    createNote(`A significant semantic shift was detected (distance from recent history: ${distance.toFixed(2)}).`);\n}"
    },
    {
      "name": "18. Legal Element Mapper",
      "author": "Az",
      "description": "Tries to map evidence to the specific legal elements of an allegation. For example, for \"Breach of Contract\", it looks for evidence of an offer, acceptance, and a breach.",
      "content": "if (case.allegations.includes(\"Breach of Contract\")) {\n    if (evidence.text.toLowerCase().includes(\"i accept your offer\")) {\n        addTag(\"Contract - Acceptance\");\n    }\n    if (evidence.text.toLowerCase().includes(\"failed to deliver\")) {\n        addTag(\"Contract - Breach\");\n    }\n}"
    },
    {
      "name": "19. Evidence Gap Suggester",
      "author": "Az",
      "description": "A smart script that suggests what evidence might be missing.",
      "content": "if (evidence.tags.includes(\"Mentioned Document\")) {\n    const docName = evidence.text.match(/\\b(contract|agreement|etc)\\b/i)[0];\n    const hasDocument = case.evidence.some(e => e.metadata.type === 'document' && e.metadata.title.includes(docName));\n    if (!hasDocument) {\n        createNote(`Missing Evidence: The '${docName}' mentioned here has not been added to the case.`);\n    }\n}"
    },
    {
      "name": "20. Narrative Summary Generator",
      "author": "Az",
      "description": "The ultimate script. For a given allegation, it pulls all linked evidence and attempts to create a chronological summary of events.",
      "content": "// This is highly conceptual\nif (case.allegations.includes(\"Harassment\")) {\n    const harassmentEvidence = case.evidence\n        .filter(e => e.allegations.includes(\"Harassment\"))\n        .sort((a, b) => new Date(a.metadata.date) - new Date(b.metadata.date));\n\n    let summary = \"Summary of Harassment:\\n\";\n    harassmentEvidence.forEach(e => {\n        summary += `- On ${e.metadata.date}, a message containing '${e.tags.join(', ')}' was received.\\n`;\n    });\n\n    // In a real scenario, this would be saved to a case summary file or note.\n    // For now, we'll add a note to the last piece of evidence.\n    if (evidence.id === harassmentEvidence.slice(-1)[0].id) {\n        createNote(summary);\n    }\n}"
    },
    {
      "name": "21. Chain of Custody Verifier",
      "author": "Az",
      "description": "For evidence that has been handled by multiple people, this script checks for a complete chain of custody log in the evidence's notes or metadata. It flags any evidence with gaps.",
      "content": "// Assumes a metadata field `evidence.metadata.custodyLog` which is an array of transfer records.\nif (evidence.metadata.type === 'physical') {\n    const log = evidence.metadata.custodyLog;\n    if (!log || log.length === 0) {\n        addTag(\"Missing Chain of Custody\");\n        createNote(\"Critical: Physical evidence is missing its chain of custody log.\");\n        return;\n    }\n    for (let i = 0; i < log.length - 1; i++) {\n        if (log[i].toPerson !== log[i+1].fromPerson) {\n            addTag(\"Broken Chain of Custody\");\n            createNote(`Chain of custody broken between ${log[i].toPerson} and ${log[i+1].fromPerson}.`);\n            setSeverity(\"Critical\");\n        }\n    }\n}"
    },
    {
      "name": "22. Metadata Anomaly Detector",
      "author": "Az",
      "description": "Scans for suspicious metadata, like a photo's EXIF data showing a date that contradicts the user-provided date, or a file that has been modified after it was supposedly collected.",
      "content": "// Assumes EXIF data is parsed into `evidence.metadata.exif`\nif (evidence.metadata.exif && evidence.metadata.exif.dateCreated) {\n    const exifDate = new Date(evidence.metadata.exif.dateCreated);\n    const providedDate = new Date(evidence.metadata.date);\n    const diffDays = Math.abs(exifDate - providedDate) / (1000 * 3600 * 24);\n    if (diffDays > 1) {\n        addTag(\"Metadata Anomaly\");\n        createNote(`EXIF creation date (${exifDate.toDateString()}) differs from provided date (${providedDate.toDateString()}).`);\n        setSeverity(\"High\");\n    }\n}"
    },
    {
      "name": "23. Duplicate Evidence Finder",
      "author": "Az",
      "description": "Uses a perceptual hash (phash) or simple checksum stored in metadata to find duplicate or near-duplicate images, even if they have different filenames.",
      "content": "// Assumes a metadata field `evidence.metadata.phash`\nif (evidence.metadata.phash) {\n    const duplicates = case.evidence.filter(e =>\n        e.id !== evidence.id && e.metadata.phash === evidence.metadata.phash\n    );\n    if (duplicates.length > 0) {\n        addTag(\"Duplicate\");\n        createNote(`This is a duplicate of evidence: ${duplicates.map(d => d.id).join(', ')}.`);\n    }\n}"
    },
    {
      "name": "24. Communication Style Analyzer",
      "author": "Az",
      "description": "Analyzes the linguistic style (e.g., sentence length, word choice, use of emojis) of a piece of evidence and compares it to the author's known baseline. Flags messages that may have been written by someone else.",
      "content": "// Conceptual - requires a baseline profile for the author.\n// `profile.authors['JohnDoe'].avgSentenceLength`\nconst sentences = evidence.text.split(/[.!?]+/);\nconst avgLength = evidence.text.length / sentences.length;\nconst authorProfile = profile.authors[evidence.metadata.author];\nif (authorProfile && Math.abs(avgLength - authorProfile.avgSentenceLength) > 10) {\n    addTag(\"Atypical Style\");\n    createNote(\"Communication style is inconsistent with author's baseline.\");\n}"
    },
    {
      "name": "25. Automated Deposition Question Generator",
      "author": "Az",
      "description": "When it finds a contradiction or a threat, this script automatically generates a potential deposition question and adds it to a case-wide \"Deposition Prep\" note.",
      "content": "function addDepoQuestion(question) {\n    // This function would append to a central case note or task list.\n    console.log(`New Depo Question: ${question}`);\n}\n\nif (evidence.tags.includes(\"Contradiction\")) {\n    addDepoQuestion(`On [Date], you stated X. However, on [Other Date], you stated Y. Can you explain this discrepancy?`);\n}\nif (evidence.tags.includes(\"Threat\")) {\n    addDepoQuestion(`Can you explain what you meant when you wrote, \"${evidence.text}\"?`);\n}"
    },
    {
      "name": "26. Expert Witness Recommender",
      "author": "Az",
      "description": "Based on the content of the evidence, this script suggests when an expert witness might be needed.",
      "content": "const financialRegex = /\\b(forensic accounting|tax fraud|embezzlement)\\b/i;\nconst techRegex = /\\b(encryption|hacking|IP address|metadata)\\b/i;\n\nif (financialRegex.test(evidence.text)) {\n    addTag(\"Expert Witness Needed\");\n    createNote(\"Consider engaging a forensic accountant for this evidence.\");\n}\nif (techRegex.test(evidence.text)) {\n    addTag(\"Expert Witness Needed\");\n    createNote(\"Consider engaging a digital forensics expert for this evidence.\");\n}"
    },
    {
      "name": "27. Automatic Redaction Suggester",
      "author": "Az",
      "description": "Identifies Personally Identifiable Information (PII) like social security numbers, bank account numbers, or home addresses and tags them for redaction before sharing.",
      "content": "const ssnRegex = /\\b\\d{3}-\\d{2}-\\d{4}\\b/;\nconst bankAccountRegex = /\\b\\d{10,16}\\b/;\nif (ssnRegex.test(evidence.text) || bankAccountRegex.test(evidence.text)) {\n    addTag(\"Redact PII\");\n    setSeverity(\"High\");\n}"
    },
    {
      "name": "28. Settlement Offer Analyzer",
      "author": "Az",
      "description": "When a settlement offer is mentioned, this script scours the case for all evidence tagged \"Financial\" and calculates a running total of claimed damages to provide context for the offer.",
      "content": "const offerRegex = /i will offer you \\$([\\d,.]+)/i;\nconst match = evidence.text.match(offerRegex);\nif (match) {\n    const offerAmount = parseFloat(match[1].replace(/,/g, ''));\n    addTag(\"Settlement Offer\");\n\n    let totalDamages = 0;\n    const financialEvidence = case.evidence.filter(e => e.tags.includes(\"Financial\"));\n    financialEvidence.forEach(e => {\n        const damageMatch = e.text.match(/you owe me \\$([\\d,.]+)/i);\n        if (damageMatch) {\n            totalDamages += parseFloat(damageMatch[1].replace(/,/g, ''));\n        }\n    });\n\n    createNote(`Settlement offer of $${offerAmount} received. Total calculated damages in case: $${totalDamages}.`);\n}"
    },
    {
      "name": "29. Cross-Case Actor Linker",
      "author": "Az",
      "description": "Identifies if an actor (e.g., a person, a company) in this case has appeared in any other case in your database. Requires a global case database API.",
      "content": "// Conceptual - requires a global `database` object.\nconst actorName = evidence.metadata.author;\nconst otherCases = database.findCasesByActor(actorName);\nif (otherCases.length > 0) {\n    addTag(\"Cross-Case Link\");\n    createNote(`Actor ${actorName} also appears in cases: ${otherCases.map(c => c.name).join(', ')}.`);\n}"
    },
    {
      "name": "30. Legal Precedent Suggester (Functional)",
      "author": "Az",
      "description": "Identifies when evidence is semantically similar to complex legal concepts, suggesting topics for precedent research.",
      "content": "// This script compares evidence against a predefined list of complex legal concepts\n// and suggests topics for further research if a strong semantic match is found.\nconst legalConcepts = [\n    { name: \"Economic Abuse\", description: \"Controlling a person's ability to acquire, use, and maintain financial resources.\" },\n    { name: \"Coercive Control\", description: \"A pattern of intimidation, degradation, isolation, and control used to harm or frighten someone.\" },\n    { name: \"Promissory Estoppel\", description: \"A legal principle that a promise is enforceable by law, even if made without formal consideration, when a party relies on that promise to their detriment.\" },\n    { name: \"Constructive Fraud\", description: \"An act that is considered fraudulent under the law even without intent to deceive, such as a breach of a legal or equitable duty.\" }\n];\n\nconst evidenceText = evidence.text;\nlet suggestions = [];\n\nlegalConcepts.forEach(concept => {\n    const similarity = lex.ai.local.calculateSimilarity(evidenceText, concept.description);\n    if (similarity > 0.65) { // Confidence threshold\n        suggestions.push(concept.name);\n    }\n});\n\nif (suggestions.length > 0) {\n    addTag(\"Legal Research Suggested\");\n    createNote(`This evidence shows semantic similarity to the following legal concepts: ${suggestions.join(', ')}. Consider researching relevant precedents.`);\n}"
    },
    {
      "name": "31. \"Smoking Gun\" Identifier",
      "author": "Az",
      "description": "This script combines multiple high-value indicators to flag a piece of evidence as a potential \"smoking gun\".",
      "content": "let score = 0;\nif (evidence.tags.includes(\"Admission\")) score++;\nif (evidence.tags.includes(\"Contradiction\")) score++;\nif (evidence.metadata.severity === \"Critical\") score++;\nif (evidence.tags.includes(\"Atypical Style\")) score++; // Suggests someone trying to hide\n\nif (score >= 3) {\n    addTag(\"Smoking Gun?\");\n    setSeverity(\"Critical\");\n    createNote(\"This evidence has multiple high-value indicators. Prioritize for review.\");\n}"
    },
    {
      "name": "32. Case Strength Barometer",
      "author": "Az",
      "description": "A meta-script that runs periodically over the whole case, assessing the ratio of evidence linked to allegations vs. unlinked evidence, and the number of \"Smoking Gun\" or \"Critical\" items, to provide a rough barometer of case strength.",
      "content": "// This would likely be a standalone script run on the case object, not on a single piece of evidence.\nconst linkedEvidence = case.evidence.filter(e => e.allegations.length > 0).length;\nconst totalEvidence = case.evidence.length;\nconst strengthRatio = linkedEvidence / totalEvidence;\nconst criticalItems = case.evidence.filter(e => e.metadata.severity === \"Critical\").length;\n\nlet strength = \"Weak\";\nif (strengthRatio > 0.5) strength = \"Moderate\";\nif (strengthRatio > 0.75) strength = \"Strong\";\nif (criticalItems > 2) strength = \"Very Strong\";\n\ncreateNote(`Case Strength Barometer: ${strength} (Ratio: ${strengthRatio.toFixed(2)}, Critical Items: ${criticalItems})`);"
    },
    {
      "name": "33. Opposing Counsel Strategy Predictor (Functional)",
      "author": "Az",
      "description": "Based on the patterns of tags across all evidence, this script predicts the opposing counsel's likely defense strategy.",
      "content": "// This script looks for patterns in the tags of all evidence to predict the opponent's strategy.\n// It relies on other scripts (like #8 Admission of Guilt and #63 Semantic Gaslighting Detector) having run first.\nconst hasSemanticGaslighting = case.evidence.some(e => e.tags.includes(\"Gaslighting (Semantic)\"));\nconst hasAdmission = case.evidence.some(e => e.tags.includes(\"Admission\"));\n\nlet prediction = null;\n\nif (hasSemanticGaslighting && !hasAdmission) {\n    prediction = \"Opposing counsel will likely attack the victim's credibility and state of mind ('unstable' defense).\";\n} else if (hasAdmission && !hasSemanticGaslighting) {\n    prediction = \"Opposing counsel may attempt a 'remorse' defense or argue admissions were taken out of context or coerced.\";\n} else if (hasSemanticGaslighting && hasAdmission) {\n    prediction = \"Opposing counsel faces a difficult case. They may try to minimize the admissions and paint the gaslighting as simple disagreements.\";\n}\n\nif (prediction) {\n    createNote(`Predicted Opposing Strategy: ${prediction}`);\n    addTag(\"Strategy Prediction\");\n}"
    },
    {
      "name": "34. Missing Narrative Link Detector",
      "author": "Az",
      "description": "Analyzes the timeline of events and points out logical gaps where evidence should exist but doesn't.",
      "content": "// Conceptual AI\nconst threat = case.evidence.find(e => e.tags.includes(\"Threat\"));\nif (threat) {\n    const followUp = case.evidence.find(e => new Date(e.metadata.date) > new Date(threat.metadata.date));\n    if (!followUp) {\n        createNote(\"Narrative Gap: A threat was made, but there is no subsequent evidence showing the outcome or de-escalation. What happened next?\");\n    }\n}"
    },
    {
      "name": "35. Evidence Forgery Risk Assessor",
      "author": "Az",
      "description": "Uses a conceptual AI model to analyze an image for signs of digital manipulation (e.g., inconsistent compression levels, pixel anomalies).",
      "content": "// Conceptual AI\nif (evidence.metadata.type === 'image') {\n    const forgeryRisk = ForgeryDetectionAI.analyze(evidence.imagePath); // returns a score 0-1\n    if (forgeryRisk > 0.8) {\n        addTag(\"Forgery Risk\");\n        setSeverity(\"Critical\");\n        createNote(`AI analysis indicates a ${forgeryRisk*100}% risk of digital manipulation.`);\n    }\n}"
    },
    {
      "name": "36. Automated Witness Vetting",
      "author": "Az",
      "description": "When a potential witness is identified, this script could (with permission) run a conceptual background check API to look for public records, conflicts of interest, or past instances of perjury.",
      "content": "// Conceptual API\nif (evidence.tags.some(t => t.startsWith(\"Potential Witness:\"))) {\n    const witnessName = evidence.tags.find(t => t.startsWith(\"Potential Witness:\")).split(\": \")[1];\n    const backgroundCheck = BackgroundCheckAPI.run(witnessName);\n    if (backgroundCheck.hasRedFlags) {\n        createNote(`Witness Vetting: ${witnessName} has potential red flags: ${backgroundCheck.flags.join(', ')}.`);\n    }\n}"
    },
    {
      "name": "37. Auto-Categorize & File Evidence",
      "author": "Az",
      "description": "An AI-powered script that reads the evidence and automatically files it under the most relevant allegation without needing explicit rules.",
      "content": "// Conceptual AI\nconst textToClassify = evidence.text;\nconst allAllegations = case.allegations;\nconst bestFitAllegation = ClassificationAI.findBestMatch(textToClassify, allAllegations);\nif (bestFitAllegation.confidence > 0.7) {\n    linkToAllegation(bestFitAllegation.name);\n}"
    },
    {
      "name": "38. Dynamic Discovery Request Drafter",
      "author": "Az",
      "description": "Goes beyond suggesting requests. This script would actually draft a formal discovery request document based on the gaps it has identified.",
      "content": "// Conceptual Document Generation\nif (evidence.tags.includes(\"Missing Evidence\")) {\n    const missingDoc = evidence.notes.find(n => n.startsWith(\"Missing Evidence:\")).split(\"'\")[1];\n    const requestDraft = DocumentGenerator.create('DiscoveryRequest', {\n        itemNumber: 1,\n        description: `All documents relating to the '${missingDoc}' mentioned in the communication dated ${evidence.metadata.date}.`\n    });\n    // save requestDraft to case files\n}"
    },
    {
      "name": "39. Case Outcome Predictor",
      "author": "Az",
      "description": "The holy grail. A conceptual AI that analyzes all evidence, case strength, linked precedents, and opposing counsel strategy to provide a probabilistic outcome prediction.",
      "content": "// Conceptual AI\nconst prediction = OutcomePredictionAI.analyze(case);\n// prediction = { outcome: \"Favorable Settlement\", confidence: 0.65, keyFactors: [\"Smoking Gun evidence\", \"Strong witness list\"] }\ncreateNote(`Outcome Prediction: ${prediction.outcome} (Confidence: ${prediction.confidence*100}%) based on: ${prediction.keyFactors.join(', ')}.`);"
    },
    {
      "name": "40. Automated Case Summary & Brief Generation",
      "author": "Az",
      "description": "A final, generative script that takes the narrative summaries, key evidence, witness lists, and legal precedents and generates a first draft of a case brief or summary judgment motion.",
      "content": "// Conceptual Document Generation\nif (case.status === \"Preparing for Trial\") {\n    const caseBriefDraft = DocumentGenerator.create('CaseBrief', {\n        caseObject: case\n    });\n    // save caseBriefDraft to case files\n    createNote(\"First draft of the case brief has been generated based on the current state of the case.\");\n}"
    },
    {
      "name": "41. AI-Powered Evidence Summarization",
      "author": "Az",
      "description": "Calls an AI model to generate a concise, neutral summary of a long piece of evidence and writes it to a \"Summary\" column in the \"Evidence\" sheet.",
      "content": "const longText = evidence.text;\nif (longText.length > 2000) { // Only summarize long texts\n    const summary = AI.analyze(\"Summarizer\", { text: longText });\n    const evidenceRow = Spreadsheet.query(\"Evidence\", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\n    Spreadsheet.updateCell(\"Evidence\", `H${evidenceRow.rowNumber}`, summary.text); // Assuming H is the Summary column\n}"
    },
    {
      "name": "42. Key Entity Extraction to Spreadsheet",
      "author": "Az",
      "description": "Uses an AI to extract all named entities (People, Places, Organizations, Dates) and populates a new \"Entities\" sheet with the entity, its type, and a link back to the source evidence.",
      "content": "Spreadsheet.createSheet(\"Entities\"); // Fails silently if it exists\nconst entities = AI.analyze(\"EntityExtractor\", { text: evidence.text });\nentities.forEach(entity => {\n    Spreadsheet.appendRow(\"Entities\", {\n        \"Entity\": entity.name,\n        \"Type\": entity.type,\n        \"SourceEvidenceID\": evidence.id\n    });\n});"
    },
    {
      "name": "43. Action Item Tracker",
      "author": "Az",
      "description": "An AI script that identifies action items or commitments (e.g., \"I will pay you on Friday\") and logs them in a new \"ActionItems\" sheet.",
      "content": "Spreadsheet.createSheet(\"ActionItems\");\nconst actionItems = AI.analyze(\"ActionItemFinder\", { text: evidence.text });\nactionItems.forEach(item => {\n    Spreadsheet.appendRow(\"ActionItems\", {\n        \"Commitment\": item.commitment,\n        \"DueDate\": item.dueDate, // The AI would extract this\n        \"SourceEvidenceID\": evidence.id\n    });\n});"
    },
    {
      "name": "44. De-identify and Anonymize to Column",
      "author": "Az",
      "description": "Uses an AI to find and replace all PII, saving this anonymized version to a new \"AnonymizedText\" column in the spreadsheet for safe sharing.",
      "content": "const anonymized = AI.analyze(\"Anonymizer\", { text: evidence.text });\nconst evidenceRow = Spreadsheet.query(\"Evidence\", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\nSpreadsheet.updateCell(\"Evidence\", `I${evidenceRow.rowNumber}`, anonymized.text); // Assuming I is the AnonymizedText column"
    },
    {
      "name": "45. Advanced Emotion & Intent Analysis (Functional)",
      "author": "Az",
      "description": "Analyzes text for nuanced emotions and perceived intent by comparing it to a list of example sentences.",
      "content": "// This script attempts to classify the primary emotion and intent behind a piece\n// of evidence by comparing it to text samples representing different categories.\nconst emotionSamples = [\n    { name: \"Anger\", text: \"I am furious about this, you will regret it.\" },\n    { name: \"Fear\", text: \"I am scared of what might happen next, please be careful.\" },\n    { name: \"Sadness\", text: \"This whole situation just makes me incredibly sad and hopeless.\" }\n];\n\nconst intentSamples = [\n    { name: \"Deceptive\", text: \"That's not what I said, you must have misunderstood me completely.\" },\n    { name: \"Conciliatory\", text: \"I understand your position and I want to find a way to make this right.\" },\n    { name: \"Threatening\", text: \"You should really think about what you're doing, there will be consequences.\" }\n];\n\nconst evidenceText = evidence.text;\n\n// Find best emotion match\nlet bestEmotion = { name: null, similarity: -1.0 };\nemotionSamples.forEach(sample => {\n    const similarity = lex.ai.local.calculateSimilarity(evidenceText, sample.text);\n    if (similarity > bestEmotion.similarity) {\n        bestEmotion = { name: sample.name, similarity: similarity };\n    }\n});\n\n// Find best intent match\nlet bestIntent = { name: null, similarity: -1.0 };\nintentSamples.forEach(sample => {\n    const similarity = lex.ai.local.calculateSimilarity(evidenceText, sample.text);\n    if (similarity > bestIntent.similarity) {\n        bestIntent = { name: sample.name, similarity: similarity };\n    }\n});\n\nif (bestEmotion.name && bestEmotion.similarity > 0.5) {\n    addTag(`Emotion: ${bestEmotion.name}`);\n}\nif (bestIntent.name && bestIntent.similarity > 0.5) {\n    addTag(`Intent: ${bestIntent.name}`);\n}"
    },
    {
      "name": "46. Legal Topic Classification",
      "author": "Az",
      "description": "Classifies evidence into specific legal topics, allowing for powerful filtering in the spreadsheet.",
      "content": "const topic = AI.analyze(\"LegalTopicClassifier\", { text: evidence.text });\nconst row = Spreadsheet.query(\"Evidence\", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\nSpreadsheet.updateCell(\"Evidence\", `L${row.rowNumber}`, topic.name); // e.g., \"Contract Law\""
    },
    {
      "name": "47. Evidence Admissibility Score",
      "author": "Az",
      "description": "Assesses evidence against rules of evidence (hearsay, relevance) and adds a preliminary \"Admissibility Score\" and reasoning to the spreadsheet.",
      "content": "const admissibility = AI.analyze(\"AdmissibilityScorer\", { text: evidence.text, metadata: evidence.metadata });\nconst row = Spreadsheet.query(\"Evidence\", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\nSpreadsheet.updateCell(\"Evidence\", `M${row.rowNumber}`, admissibility.score); // e.g., 0.75\nSpreadsheet.updateCell(\"Evidence\", `N${row.rowNumber}`, admissibility.reasoning);"
    },
    {
      "name": "48. Argument Strength Assessor",
      "author": "Az",
      "description": "When evidence is linked to an allegation, this AI evaluates how strongly the evidence supports it, providing a score and explanation in a \"SupportStrength\" column.",
      "content": "if (evidence.allegations.length > 0) {\n    const allegationText = case.allegations.find(a => a.name === evidence.allegations[0]).description;\n    const strength = AI.analyze(\"ArgumentStrength\", { premise: evidence.text, conclusion: allegationText });\n    const row = Spreadsheet.query(\"Evidence\", `SELECT * WHERE EvidenceID = '${evidence.id}'`)[0];\n    Spreadsheet.updateCell(\"Evidence\", `O${row.rowNumber}`, strength.score);\n}"
    },
    {
      "name": "49. Create a Dynamic Case Timeline Sheet",
      "author": "Az",
      "description": "Queries all evidence, sorts it by date, and uses an AI summarizer on each piece to generate a new, clean \"Timeline\" sheet.",
      "content": "Spreadsheet.createSheet(\"Timeline\");\nconst allEvidence = Spreadsheet.query(\"Evidence\", \"SELECT * ORDER BY Date ASC\");\nallEvidence.forEach(row => {\n    const summary = AI.analyze(\"Summarizer\", { text: row.Text });\n    Spreadsheet.appendRow(\"Timeline\", {\n        \"Date\": row.Date,\n        \"EventSummary\": summary.text,\n        \"SourceEvidenceID\": row.EvidenceID\n    });\n});"
    },
    {
      "name": "50. Identify Key Witnesses from Spreadsheet Data",
      "author": "Az",
      "description": "Queries the \"Entities\" sheet for all \"Person\" entities, counts their mentions, and creates a \"KeyWitnesses\" sheet sorted by frequency.",
      "content": "Spreadsheet.createSheet(\"KeyWitnesses\");\nconst witnesses = Spreadsheet.query(\"Entities\", \"SELECT Entity, COUNT(*) as Mentions WHERE Type = 'Person' GROUP BY Entity ORDER BY Mentions DESC\");\nwitnesses.forEach(witness => {\n    Spreadsheet.appendRow(\"KeyWitnesses\", witness);\n});"
    },
    {
      "name": "51. AI-Generated Contradiction Matrix",
      "author": "Az",
      "description": "Systematically compares evidence in the spreadsheet and, if it finds a contradiction, creates a \"ContradictionMatrix\" sheet logging the conflict.",
      "content": "Spreadsheet.createSheet(\"ContradictionMatrix\");\nconst allEvidence = Spreadsheet.query(\"Evidence\", \"SELECT EvidenceID, Text\");\nfor (let i = 0; i < allEvidence.length; i++) {\n    for (let j = i + 1; j < allEvidence.length; j++) {\n        const result = AI.analyze(\"ContradictionFinder\", { textA: allEvidence[i].Text, textB: allEvidence[j].Text });\n        if (result.isContradictory) {\n            Spreadsheet.appendRow(\"ContradictionMatrix\", {\n                \"EvidenceID_A\": allEvidence[i].EvidenceID,\n                \"EvidenceID_B\": allEvidence[j].EvidenceID,\n                \"Explanation\": result.explanation\n            });\n        }\n    }\n}"
    },
    {
      "name": "52. Cluster Similar Evidence into a New Sheet",
      "author": "Az",
      "description": "Uses an AI embedding model to group semantically similar evidence, creating a \"Clusters\" sheet that maps each piece of evidence to a Cluster ID.",
      "content": "Spreadsheet.createSheet(\"Clusters\");\nconst allEvidence = Spreadsheet.query(\"Evidence\", \"SELECT EvidenceID, Text\");\nconst clusters = AI.analyze(\"Clusterer\", { documents: allEvidence.map(e => e.Text) });\nclusters.forEach((clusterId, index) => {\n    Spreadsheet.appendRow(\"Clusters\", {\n        \"EvidenceID\": allEvidence[index].EvidenceID,\n        \"ClusterID\": clusterId\n    });\n});"
    },
    {
      "name": "53. Generate Deposition Questions for a Witness",
      "author": "Az",
      "description": "Selects a witness from the \"KeyWitnesses\" sheet, queries all associated evidence, and uses a generative AI to create tailored deposition questions in a new sheet.",
      "content": "const topWitness = Spreadsheet.query(\"KeyWitnesses\", \"SELECT Entity LIMIT 1\")[0].Entity;\nSpreadsheet.createSheet(`DepoPrep_${topWitness}`);\nconst relatedEvidence = Spreadsheet.query(\"Entities\", `SELECT SourceEvidenceID WHERE Entity = '${topWitness}'`);\nconst texts = relatedEvidence.map(e => Spreadsheet.query(\"Evidence\", `SELECT Text WHERE EvidenceID = '${e.SourceEvidenceID}'`)[0].Text);\n\nconst questions = AI.analyze(\"DepoQuestionGenerator\", { context: texts.join(\"\\n\\n\") });\nquestions.forEach(q => {\n    Spreadsheet.appendRow(`DepoPrep_${topWitness}`, { \"Question\": q });\n});"
    },
    {
      "name": "54. Predict Missing Document Types",
      "author": "Az",
      "description": "The AI analyzes existing documents and communications in the spreadsheet to predict what standard documents are likely missing, logging them in a \"DiscoveryGaps\" sheet.",
      "content": "Spreadsheet.createSheet(\"DiscoveryGaps\");\nconst allText = Spreadsheet.query(\"Evidence\", \"SELECT Text\").map(r => r.Text).join(\"\\n\");\nconst missingDocs = AI.analyze(\"MissingDocumentPredictor\", { context: allText, caseType: case.type });\nmissingDocs.forEach(doc => {\n    Spreadsheet.appendRow(\"DiscoveryGaps\", { \"SuggestedMissingDocument\": doc });\n});"
    },
    {
      "name": "55. Financial Anomaly Detection in Transactions",
      "author": "Az",
      "description": "If the spreadsheet has a \"Transactions\" sheet, this AI script analyzes it for anomalies, flagging them for review in a new \"FlaggedTransactions\" sheet.",
      "content": "Spreadsheet.createSheet(\"FlaggedTransactions\");\nconst transactions = Spreadsheet.query(\"Transactions\", \"SELECT *\");\nconst flagged = AI.analyze(\"FinancialAnomalyDetector\", { transactions: transactions });\nflagged.forEach(txn => {\n    Spreadsheet.appendRow(\"FlaggedTransactions\", { ...txn, \"Reason\": \"AI Flagged\" });\n});"
    },
    {
      "name": "56. Draft a Case Summary from Spreadsheet Data",
      "author": "Az",
      "description": "An AI script that reads multiple sheets (Evidence, Timeline, Allegations) to generate a narrative first draft of a case summary, writing it to a \"CaseSummary\" sheet.",
      "content": "Spreadsheet.createSheet(\"CaseSummary\");\nconst context = {\n    allegations: Spreadsheet.query(\"Allegations\", \"SELECT *\"),\n    timeline: Spreadsheet.query(\"Timeline\", \"SELECT *\"),\n    keyEvidence: Spreadsheet.query(\"Evidence\", \"SELECT * WHERE Severity = 'Critical'\")\n};\nconst summary = AI.analyze(\"CaseSummaryGenerator\", { context: context });\nSpreadsheet.appendRow(\"CaseSummary\", { \"GeneratedSummary\": summary.text });"
    },
    {
      "name": "57. \"What-If\" Scenario Analysis",
      "author": "Az",
      "description": "A user adds hypothetical evidence to a \"WhatIf\" sheet. This script uses an AI to predict its impact on the case, writing the analysis back to the sheet.",
      "content": "const scenarios = Spreadsheet.query(\"WhatIf\", \"SELECT * WHERE Analysis IS NULL\");\nscenarios.forEach(scenario => {\n    const impact = AI.analyze(\"ImpactPredictor\", { case: case, newEvidence: scenario.HypotheticalEvidence });\n    Spreadsheet.updateCell(\"WhatIf\", `B${scenario.rowNumber}`, impact.analysis); // Assuming B is Analysis column\n});"
    },
    {
      "name": "58. Auto-Update Allegation Status in Spreadsheet",
      "author": "Az",
      "description": "Periodically reviews all evidence linked to an allegation and, if sufficiently supported, updates a \"Status\" column for that allegation in the \"Allegations\" sheet.",
      "content": "const allegations = Spreadsheet.query(\"Allegations\", \"SELECT *\");\nallegations.forEach(allegation => {\n    const relatedEvidence = Spreadsheet.query(\"Evidence\", `SELECT * WHERE allegations LIKE '%${allegation.Name}%'`);\n    const strength = AI.analyze(\"AllegationStrength\", { evidence: relatedEvidence });\n    if (strength.score > 0.8) {\n        Spreadsheet.updateCell(\"Allegations\", `C${allegation.rowNumber}`, \"Sufficiently Supported\"); // C is Status column\n    }\n});"
    },
    {
      "name": "59. Identify the \"Most Persuasive\" Evidence",
      "author": "Az",
      "description": "An AI ranks all evidence in the spreadsheet based on relevance, admissibility, and impact, then creates a \"Top5Evidence\" sheet with links to these key pieces.",
      "content": "Spreadsheet.createSheet(\"Top5Evidence\");\nconst allEvidence = Spreadsheet.query(\"Evidence\", \"SELECT *\");\nconst rankings = AI.analyze(\"PersuasivenessRanker\", { evidence: allEvidence, allegations: case.allegations });\nrankings.slice(0, 5).forEach(item => {\n    Spreadsheet.appendRow(\"Top5Evidence\", { \"EvidenceID\": item.id, \"Rank\": item.rank, \"Reason\": item.reason });\n});"
    },
    {
      "name": "60. AI-Powered Spreadsheet Query via Natural Language",
      "author": "Az",
      "description": "A user writes a question in a \"Queries\" sheet. The script sends it to an AI that converts it into a formal query, executes it, and pastes the results into the sheet.",
      "content": "const newQueries = Spreadsheet.query(\"Queries\", \"SELECT * WHERE Result IS NULL\");\nnewQueries.forEach(query => {\n    const formalQuery = AI.analyze(\"NLQtoSQL\", { question: query.Question });\n    try {\n        const results = Spreadsheet.query(formalQuery.sheet, formalQuery.sql);\n        const resultsAsText = JSON.stringify(results, null, 2);\n        Spreadsheet.updateCell(\"Queries\", `B${query.rowNumber}`, resultsAsText);\n    } catch (e) {\n        Spreadsheet.updateCell(\"Queries\", `B${query.rowNumber}`, `Error: ${e.message}`);\n    }\n});"
    },
    {
      "name": "61. Semantic Gaslighting Detector (Functional)",
      "author": "Az",
      "description": "This script uses semantic similarity to detect phrases that are variations of gaslighting, even if they don't use the exact keywords from a predefined list.",
      "content": "const gaslightingExamples = [\n    \"You are being irrational and overly emotional.\",\n    \"That is not what happened, you are remembering it wrong.\",\n    \"I was just joking, you are too sensitive.\",\n    \"You are making a big deal out of nothing.\",\n    \"I am sorry you feel that way.\"\n];\nconst evidenceText = evidence.text;\nlet isGaslighting = false;\ngaslightingExamples.forEach(example => {\n    if (lex.ai.local.calculateSimilarity(evidenceText, example) > 0.7) {\n        isGaslighting = true;\n    }\n});\nif (isGaslighting) {\n    addTag(\"Gaslighting (Semantic)\");\n    linkToAllegation(\"Emotional Abuse\");\n}"
    },
    {
      "name": "62. Simple Tutorial: \"Hello, Dynamic Screens!\"",
      "author": "Az",
      "description": "This script demonstrates the most basic use of the `lex.ui` object. It creates a new, clickable menu item in the main navigation rail. When you click this item, it opens a brand new screen that is completely defined by a JSON schema within the script.",
      "content": "const myScreenSchema = {\n  title: \"Hello World\",\n  elements: [\n    { type: \"text\", properties: { text: \"Welcome to your first scripted screen!\", size: 20 } },\n    { type: \"spacer\", properties: { height: 16 } },\n    { type: \"button\", properties: { label: \"Say Hello\", onClickAction: \"show_toast:Hello from a scripted button!\" } }\n  ]\n};\nlex.ui.addOrUpdate(\"my_first_screen_button\", \"My Screen\", true, \"scripted_screen/\" + JSON.stringify(myScreenSchema));"
    },
    {
      "name": "63. Advanced Tutorial: AI-Powered In-App Guide",
      "author": "Az",
      "description": "This script demonstrates combining the AI and UI APIs. It creates a \"Tutorial & Tip\" menu item that opens a custom screen featuring a \"Tip of the Day\" freshly generated by the AI.",
      "content": "const tipPrompt = \"In one sentence, give me a useful and uncommon productivity tip for legal professionals.\";\n// Note: This uses the cloud-based generative AI, not the local one.\nconst aiGeneratedTip = lex.ai.generate.generateContent(tipPrompt);\nconst tutorialSchema = {\n  title: \"App Tutorial\",\n  elements: [\n    { type: \"text\", properties: { text: \"Welcome to The Lexorcist!\", size: 24 } },\n    { type: \"text\", properties: { text: \"This app helps you organize, analyze, and build your case narrative.\", size: 16 } },\n    { type: \"spacer\", properties: { height: 24 } },\n    { type: \"text\", properties: { text: \"AI Tip of the Day:\", size: 20 } },\n    { type: \"text\", properties: { text: aiGeneratedTip, size: 16 } },\n    { type: \"spacer\", properties: { height: 24 } },\n    { type: \"text\", properties: { text: \"Use the navigation rail on the left to manage Cases, Evidence, and more.\", size: 16 } }\n  ]\n};\nlex.ui.addOrUpdate(\"ai_tutorial_screen_button\", \"Tutorial & Tip\", true, \"scripted_screen/\" + JSON.stringify(tutorialSchema));"
    }
  ],
  "templates": [
    {
      "id": "1",
      "name": "Generic Affidavit",
      "description": "A standard, general-purpose affidavit template.",
      "content": "<html><body><h2>AFFIDAVIT</h2><p>I, [Name], being duly sworn, depose and say:</p><p>1. [Statement 1]</p><p>2. [Statement 2]</p></body></html>",
      "authorName": "Az",
      "authorEmail": "az@example.com",
      "court": "Generic"
    },
    {
      "id": "2",
      "name": "Motion to Compel",
      "description": "A template for a motion to compel discovery.",
      "content": "<html><body><h2>MOTION TO COMPEL</h2><p>Plaintiff/Defendant, [Your Name], moves this court to compel discovery from [Opposing Party].</p></body></html>",
      "authorName": "Az",
      "authorEmail": "az@example.com",
      "court": "Supreme Court of California"
    },
    {
      "id": "3",
      "name": "Notice of Deposition",
      "description": "A template for a notice of deposition.",
      "content": "<html><body><h2>NOTICE OF DEPOSITION</h2><p>PLEASE TAKE NOTICE that pursuant to [Rule], the deposition of [Deponent Name] will be taken at [Location] on [Date] at [Time].</p></body></html>",
      "authorName": "Az",
      "authorEmail": "az@example.com",
      "court": "Supreme Court of Texas"
    }
  ]
}